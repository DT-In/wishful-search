# WishfulSearch

WishfulSearch is a natural language search module for JSON arrays. Take any JSON array you have (notifications, movies, flights, people) and filter it with complex questions. WishfulSearch takes care of the prompting, database management, object conversion and query formatting.

Apache-2 licensed - but recommended to fork and modify, and I'm happy to help if you run into issues.

**This repo is the work of a single dev, and meant to be for educational purposes. Use at your own risk!**

## Key Features

- AI Quickstart: generate everything you need to use the library from a single, untyped JS object.

- Bundled sqlite db: WishfulSearch comes included with a performant database, and the adapters should you wish to access it.

- Server and client-side: Includes bundled file to import as a script, or install from npm.

- Ready to use multiple models and providers: GPT, Claude, Mistral adapters are provided, with specific-model template generation from the same input with advanced things like model-resume. Feel free to swap models midway through a conversation!

- Automated few-shot generation: Use a smarter model to generate few-shot examples from a few questions, retemplate and insert into a prompt of a local model for instantly better results.

- Single production dependency: The only prod dependency is sql.js, so you're not dragging along [Guy Fieri](https://nodesource.com/blog/is-guy-fieri-in-your-node-js-packages/) if you don't want to.

- Exposed prompts: Use the entire functionality, or don't. Most key functions are exposed, including those for prompt generation. Use as you wish.

The search functionality from WishfulSearch has a few key benefits:

1. Search history: The LLM is appropriately fed past queries, so users can ask contextual questions ('What trains go to paris?' followed by 'any leaving at 10 am') and have auto-merged filters.
2. Automated Dynamic Enums: The structured DDL format used internally (and generated by the AI Quickstart) contains the option for you to propose static examples for each column, to make the contents of a field clear to the model. WishfulSearch can also dynamically generate example values (with type detection) on each insert, so this is done with no effort. It can also pick the most frequent values in a column, or find the range and pass that on for token savings.
3. Safer search: While running auto-generated queries can never be properly safe. WishfulSearch implements a few filters to sanitize the output, as well only having the LLM generate partial queries to try and improve safety. Ideally this is used in cases where having the entire db exposed to the user is not a security risk.

## How it works

A few things happen in order to perform a search:

1. The JSON objects are converted to relational tables with foreign-keys and stored in the embedded sqlite db.
2. Dynamic enum values are generated to help inform the LLM about the contents of each relevant column.
3. User queries are translated into complete context, including table structure, contents, past questions, and passed to the LLM to generate a SQL query that retrieves the relevant ids.
4. Results of the query are (optionally) used to retrieve the relevant object and returned to the caller.

## Installation

Server:

```bash
npm i wishful-search
```

Client:

[Just get the bundled wishfulsearch.js], or compile a smaller one yourself from source. More instructions coming if this ends up a common use-case.

## Usage

### Selecting your model

You'll need an [openai] or [anthropic] instance (unless you're using [Ollama] and Mistral, in which case you just need to pull in an adapter).

```typescript
import OpenAI from 'openai';
const openai = new OpenAI();

import Anthropic from '@anthropic-ai/sdk';
const anthropic = new Anthropic();

const GPTLLMAdapter = LLMAdapters.getOpenAIAdapter(openai, {
  model: 'gpt-4',
});

const ClaudeLLMAdapter = LLMAdapters.getClaudeAdapter(
  Anthropic.HUMAN_PROMPT,
  Anthropic.AI_PROMPT,
  anthropic,
  {
    model: 'claude-2',
  },
);

const MistralLLMAdapter = LLMAdapters.getMistralAdapter({
  model: 'mistral',
  temperature: 0.1,
});
```

You can now use any of these for the Quickstart or Search functions.

### Quickstart

WishfulSearch needs three things from you:

1. Structured DDL: This is just an object that encodes the column names, types, examples, description and so on, in the SQL tables that are created.
2. ObjectToRelational Function: This is the function that takes a (nested) object and converts it to flat rows that can be inserted into tables.
3. Primary table and column: Just the name of the main table (usually the first one) and the column inside the main table to be used as the retrieval id.
4. (Optional) Few-shot learning: [This is the most useful thing you can do](https://olickel.com/everything-i-know-about-prompting-llms#fewshotlearningtakethebotfishing) to improve performance. Look through the examples, or generate your own at runtime with a function call.
5. (Optional) sql.js wasm file: If you use this client-side, you'll need to provide a URL or a file that sql.js can use to do it's thing. [You can look here](https://github.com/sql-js/sql.js#usage) for more information.

All of the required pieces can be generated by the AI Quickstart:

```typescript
import OpenAI from 'openai';
const openai = new OpenAI();
import { autoAnalyzeObject, LLMAdapters } from 'wishful-search';
const GPTLLMAdapter = LLMAdapters.getOpenAIAdapter(openai, {
  model: 'gpt-4',
});
const results = await autoAnalyzeObject(
  movies[0],
  GPTLLMAdapter.callLLM,
  '~/tmp',
);
```

GPT-4 and Claude-2 perform similarly and are recommended.

`results` will contain the same info as an `analysis_{date}.md` file placed in the directory of your choice. The file should contain instructions, along with the structured DDL and the ObjectToRelational function. Make sure to read the code - if your objects are complex it might need some tweaking - before you use it!

Smart models can get your 99% of the way there in most cases, but some common things to look out for:

1. No dynamic enum settings in the structured DDL - you may not need these, but GPT-4 finds it hard to recommend any.
2. No default values in case your objects are sometimes missing fields. We generate the entire thing from a single object, so the model simply doesn't know which fields are missing or optional. Providing your own typespec as a parameter should fix this.

### Create

Once you have these, you can create a new WishfulSearch instance:

```typescript
const wishfulSearchEngine = await WishfulSearchEngine.create(
    'flights', // Name for your search instance, for labelling
    MOVIES_DDL, // Structured DDL
    {
      table: 'Movies', // Primary table
      column: 'id', // Primary id column
    },
    movieToRows, // Object to relational function
    {
      enableTodaysDate: true, // Inform the model about the date
      fewShotLearning: [], // Few-shot examples
    },
    GPT4LLMAdapter.callLLM, // LLM calling function
    (movie: Movie) => movie.id, // Object to id function
    true, // Save question history?
    true, // Enable dynamic enums on insert?
    true // Sort dynamic enums by frequency? Light performance penalty on insert but better searches and token savings
  	undefined // sql.js wasm URL
  );
```

### Insert

You can insert your objects into the instance by simply passing them in:

```typescript
const errors = wishfulSearchEngine.insert(TEST_MOVIES);
```

In this case, any insertion errors are passed back to you as an array. If you enable the second parameter, all insertion is rolled back when an error is encountered, and an exception is thrown.

### AI Few-shot generation

Use larger models to teach smaller models how to behave in a few lines! Import a smarter model adapter (see above) and pass it into `autoGenerateFewShot`.

```typescript
await wishfulSearchEngine.autoGenerateFewShot(
  SmarterLLMAdapter.callLLM,
  [
    {
      question: 'something romantic?',
    },
    {
      question: 'from the 80s?',
    },
    {
      question: 'okay sci-fi instead.',
      clearHistory: true,
    },
  ],
  false, // Should we remove questions that don't get results?
  false, // throw an error on invalid questions
  true, // Be verbose
);
```

`clearHistory` is recommended in between, to teach the model when to reset the filters based on user questions.

The function also returns the same format of question-answers used to create the instance, so you can save or edit it - or mix and match with generations from different models!

### Search

This is the easy bit.

```typescript
const results = (await wishfulSearchEngine.search(
  'Something romantic but not very short from the 80s',
)) as Movie[];
```

## Other utilities

- `llm-adapters.ts` exposes the templating functions for each model.
- `WishfulSearchEngine` exposes the following additional functions:
  - `generateSearchMessages` returns (in OpenAI message format) the messages that go to the LLM to generate the query.
  - `searchWithPartialQuery` can be used to perform the search with the query response you get from the LLM.

## Where are the prompts?

I tend to read repos prompt first. In this case, most of the complexity is in formatting the output and injecting things at the right time, but if you'd like to do the same, here are the prompts for [AI Quickstart] and for [Search].

## TODO

1. Tests: More robust tests are needed before production usage. Unfortunately that's outside my scope at the moment, but I'll update the repo if I get around to it! Help would be appreciated.
2. Client-side testing: The client-side bundle has been tested in a limited fashion. It's hard to keep running all the toolchains without automated testing for now. If you run into any issues, let me know.

## Examples

The provided example uses the [Kaggle Movies] dataset. It's too big to include here, but you can download `movies_metadata.csv` and use the test file to start the search!
